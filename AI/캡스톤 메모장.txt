캡스톤 메모장

구현 기능

1. 실시간 개인화 추천을 위한 실시간 갱신 기능 (마이페이지에서 자신의 백준, solved.ac 정보 갱신)
-> 매우 중요 기능
-> 갱신할 때마다 백준과 solved.ac에서 그 아이디의 정보들(푼 문제들의 번호만 크롤링해오는 코드 실행)
-> 문제 번호들을 크롤링해오면, 문제 정보 테이블(문제에 대한 정보가 담겨져있는 데이터 프레임)을 통해
그 사용자의 알고리즘 분류 수, 푼 문제 수, 해결한 티어 수 등을 갱신
 
2. 매칭 상대 간의 간단한 채팅 기능 (시간 되면 구현)


#1 개인화 문제 추천 -> 

1. 백준, solved.ac 기반으로 자신이 푼 문제, 티어 기반으로 추천을 해줌.
2. 문제를 알고리즘, 티어별로 나눠서 그 사용자가 푼 문제의 알고리즘 수, 티어 수로 나눠서 추천도 가능.

단순히 문제 번호로 GCN 모델 사용할 수 있겠고, (나랑 비슷한 문제를 푼 사람들이 풀었던 문제를 추천)

모든 유저 유사도를 구해서 사용자의 유사도와 비교 후 가장 유사도가 높은 사람과의 문제 비교 후 추천. (시간이 좀 걸림)
(유저 티어, 유저가 푼 문제들의 티어 수, 알고리즘 분류 수 등을 이용하여 유저 유사도를 구함)

문제에 대한 정보(정답률, 알고리즘(원 핫 인코딩), 제출 횟수, 티어)  를 각각의 피처로 하여 유사도를 측정하고,
사용자가 푼 문제들의 유사도만 가져와서 그 사용자의 문제 특성 유사도를 구하고 그 유사도와 가장 비슷한 문제들을 추천.
(문제 기반 추천)

사용자의 틀렸습니다, 시간초과 비중이 높은 문제들과 가장 유사한 문제들을 추천. 

#2 개인화 팀원 매칭 추천 ->

1. 위에서 설명한 유저 유사도를 기반으로 가장 높은 유사도의 팀원 추천.
(여기에 자주 푼 시간대 정보까지 넣을 수 있다면 좋지만, 데이터를 구하지 못 할 수도 있다. 단, 보통 몇월 달에 많이 풀었는지는 가져올 수 있을 것으로 보임. 가져올 수 있으면 넣고 안되면 넣지마)


데이터 프레임

문제 데이터 프레임 - 

각 문제 번호를 기준으로 제출 수, 정답 률, 문제 티어(원 핫 인코딩), 알고리즘 분류(원 핫 인코딩) 피처 사용.

사용자 데이터 프레임 - 

각 사용자를 기준으로 푼 문제 수, 사용자 티어(원 핫 인코딩), 상위 100, 50, 10 문제 티어 난이도 합(총 3개), 
최장 몇일 연속 문제 해결. 각 알고리즘 별 푼 문제의 수 및 레이팅, 각 문제 티어 별 푼 문제의 수, 
맞았습니다 수, 틀렸습니다 수, 시간 초과 수, 메모리 초과 수, 출력 초과 수 런타임 에러, 컴파일 에러 수, 학교 분류(학교 중요하니까 가중치 더 주기).

그리고, 푼 문제 번호들도 데이터 프레임에 저장해 놓으면 그 부분만 떼서 GCN 모델을 위한 입력 값으로 써도 됨. 

각 피처마다 중요 피처는 가중치를 더 줘서 유사도를 표현해도 됨.

이외에도 EDA하면서 피처로 쓸만한 거 더 추가하고, 쓸모 없어 보이거나 중요도 측정 후 낮은 피처는 차원의 저주를 피하기 위해 과감히 삭제.'

@틀렸습니다, 시간초과 이런거 분석해서 그 틀린 문제와 비슷한 문제를 추천해주는 것. 



사용자가 엄청 많은데, 이 많은 사용자를 다 가져올 순 없어. 어떠한 기준을 가지고 특정 범위 내의 사람들만 뽑아야해.

그 기준에 대해서 ->

이상치에 해당하는 유저가 없도록 해야함. 

1: 티어
플래1~골드5 범위 내의 사람들을 가져오는 것

2: 푼 문제 개수
5000~100개 까지의 문제를 푼 사람들을 가져오는 것


추처 시스템이 잘 추천해주는지 어떻게 확인할 것인가? -> 실제 서비스를 하여 CTR, PV와 같은 지표로 확인할 수 없으므로, 평가 지표로 성능 확인

Precision@K: 내가 추천한 아이템 K개 중에 실제 사용자가 관심있는 아이템의 비율
Recall@K: 사용자가 관심있는 모든 아이템 중에서 내가 추천한 아이템 K개가 얼마나 포함되는지 비율

AP@K: Precision@1부터 Precision@K 까지의 평균값을 의미
MAP@K: 모든 유저에 대한 Average Precision 값의 평균

NDCG: 추천 결과에 따라 구해진 DCG를 IDCG로 나눈 값 


생각해봐.... 나와 비슷한 다른 사람이 푼 문제를 알아서 뭐해?

나와 비슷한 티어의 사람들이 푼 문제..
내가 풀었던 문제들과 비슷한 유형의 문제.. 

그거보다는 내가 틀렸던 문제들과 비슷한 문제를 추천해주는 것.
내가 약한 알고리즘에 대한 문제들과 비슷한 문제를 추천해주는게 제일 중요하지 않을까?... 

크롤링 방식 -> 원하는 범위의 유저들 이름들 모으고, 그거 돌면서 크롤링할건데, 크롤링은 
 제출을 돌면서 모두 하나씩 세는 것이 있을 것이다... 사전 형식으로 크롤링 해도 되긴 해.

문제 긁어오는 거는 실버5부터 플래1 범위까지만 긁어오는것으로 하자. 


문제들 긁어오고 사용자의 전체 제출만 긁어와서 정제하는게 더 효율적일거같기도하다.


코테 합격자들을 어떻게 크롤링할거냐.

문제 크롤링:
실버 5 ~ 다이아 4 까지 크롤링.

방법: solved.ac에 각 문제별 목록이 있음. 이거를 크롤링해와서 리스트로 만들고,
그 리스트로 백준에서 문제 긁어오기. 중간중간 리스트 어디까지 갔는지 확인하는거 필수! -> 크롤링 과정 중간에 끊기는건 다반사니까.
그리고, solved.ac에서 알고리즘 분류 긁어와야한다. 백준에서는 로그인해야 알고리즘 분류가 뜨기때문에, 크롤링해오기가 힘듦.

긁어올 것: 문제 번호 -> 티어, 제출 횟수, 정답, 맞힌 사람, 정답 비율, 시간 제한, 메모리 제한, 알고리즘, 문제 이름

유저 크롤링:
실버 5 ~ 플래 1 유저까지 크롤링.

방법: solve.ac에 유저 랭킹이 있다. 이거를 실버 5 ~ 플래 1 유저까지 크롤링해오는데, 옆에 제출 수까지 크롤링해온다.
그러고나서, 그 결과 나온 데이터프레임에서 푼 문제가 100개 이상인 사람들만 골라내서 그 사람들의 정보만 크롤링해온다.

그리고, 비기능적 요구사항에, 100문제 이상 푼 유저가 아니면 정확한 추천을 해드리기 어렵다는 그것을 코멘트를 주거나.
100문제 이하면 인기도 기반, 다른 기반 등으로 추천하고 100문제 이상이면 유저기반, 문제기반 추천을 해주도록 하자.

긁어올 것: 유저 닉네임 -> 제출 정보 다 가지고옴. -> 맞혔습니다, 틀렸습니다. 시간초과, 제출 시간(시간도 고려) 이런거 다 가져와.

그럼 유저는 다 같고 문제가 있고, 그 문제 관련해서 쫙있겠지? 

그러고 이제 정제하는거야.

groupby로 묶어서 한 유저의 문제와 그 문제의 풀이 이력을 쫙 정리할 수도 있겠고, 시간 순으로도 있으니까, SasRec같은 RNN 계열의 추천 모델도 사용할 수 있지. 

데이터가 언제 기준으로 크롤링 된건지 작성해놓자. 그래야 나중에 데이터 갱신할 때 달라지는거 차이 볼 수 있으니까.

-> 2023.09.18 데이터를 기준으로 개발되었습니다. 이렇게.

-------------------------------------------------------------------------------------------------------------------------------------------------------

자 이제 FM모델 다 끝났고, API를 따야하는데, 내가 FastAPI로 정보를 보내줄거라, API를 따놓는게 맞긴해. 

그래서 py파일 만들고,

필요한 csv파일들이랑, 학습하는 부분?.... 아 예측하는 파일을 먼저 만들어야지.


새로운 사용자 -> 크롤링 과정을 거치긴 해야함.

중간중간에 데이터 크롤링하여 데이터 최신화 한다고 가정.

데이터가 너무 적은 사용자는 인기도 기반 추천을 사용.


이미 모든 사용자에 대한 모델 학습은 이미 이루어진 상태임.



1. 사용자의 아이디를 주면, 아이디를 기반으로 그 사람이 풀지 않은 문제들만으로 test파일 만드는 함수. -> 각각의 모델들의 input file을 만드는 함수.


2. 사용자의 아이디와 test파일을 인자로 주면(사용자 폴더가 따로 있어야 할 듯), 그 test 파일을 사용하여 모델(앙상블 포함) 돌려서 예측하고 결과 값 반환.


사용해볼 모델:

CatBoost, GCN계열, FFM, DEEPFFM, Wide and Deep, GraphSAGE(이게 제일 좋아보이긴 함...)


해야할 일:

아이디 기반으로 그 사람이 풀지 않은 문제들의 test파일 만드는 함수.

모듈화하고 깃에 올리기.

모델 더 실행해보고 고도화하기. 현재 FFM, Catboost썼으니까 이거는 좀 나중에 해보자.


유저티어를 기준으로 그 아래로 쭉, 그리고 +2까지만의 문제들 중에



